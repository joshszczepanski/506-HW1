---
title: "HW-1Quarto"
format: html
editor: visual
---


```{r}
# Install necessary packages

#install.packages("tidyverse")    # Includes dplyr, ggplot2, readr, etc.
#install.packages("readr")        # For reading .csv and .txt files
#install.packages("dplyr")        # For data manipulation
#install.packages("ggplot2")      # For plotting (if needed)
#install.packages("stringr")      # For string manipulation
#install.packages("purrr")        # For functional programming
#install.packages("tibble")       # Enhanced data frames
#install.packages("broom")        # For tidying statistical output
#install.packages("data.table")   # Efficient data import/manipulation
#install.packages("janitor")      # For cleaning variable names
#install.packages("psych")        # For correlation matrices and descriptives


#1 A)

#Import the data frame "abalone"
abalone <- read.table("/Users/joshszczepanski/Downloads/abalone/abalone.data", sep = ",", header = FALSE)

#Assign appropriate column names
colnames(abalone) <- c(
  "sex", "length", "diameter", "height",
  "whole_weight", "shucked_weight",
  "viscera_weight", "shell_weight",
  "rings")


#1 B)
#Generate a table that shows the number of observations belonging to each sex
table(abalone$sex)

# The table shows F: 1307, I: 1342, M: 1528


#1 C1)
#Isolate just the weights and rings columns
allweights_and_rings_column <- abalone[ ,c("whole_weight", "shucked_weight",
  "viscera_weight", "shell_weight", "rings")]
                      
# Compute correlations between the first 4 columns (the weights) and the 'rings' column using sapply
correlations_with_rings <- sapply(allweights_and_rings_column[1:4], function(x) cor(x, allweights_and_rings_column$rings))

correlations_with_rings

# Identify which weight has the highest correlation.  

# **Attribution of Sources Note: Here I used assistance from Microsoft Copilot to help figure out that I need to use the "names" function. Initially, I wrote which.max(correlations_with_rings) and that just returned me the column number '4'

max_cor_weight <- names(which.max(correlations_with_rings))

# Identify correlation of highest correlating weight.
max_cor_value <- max(correlations_with_rings)


#display weight with highest correlation and its value
max_cor_weight
max_cor_value

# The weight with the highest correlation is: shell_weight it has a correlation of 0.6276 

#1 C2)

#Isolate each sex 
abalone_F <- abalone[abalone$sex == "F", ]
abalone_M <- abalone[abalone$sex == "M", ]
abalone_I <- abalone[abalone$sex == "I", ]

# Store the correlations of shell weight and rings for each isolated sex
correlation_F <- cor(abalone_F$shell_weight, abalone_F$rings)
correlation_M <- cor(abalone_M$shell_weight, abalone_M$rings)
correlation_I <- cor(abalone_I$shell_weight, abalone_I$rings)

# Store correlations into one vector

# **Attribution of Sources Note: Here I used assistance from Microsoft Copilot to help me figure out that I needed to set each correlation equal to the original sex names and couldn't just write c(correlation_F, correlation_M, correlation_I)

correlation_by_sex <- c(F = correlation_F, M = correlation_M, I = correlation_I)

# Display the correlations
correlation_by_sex

# Identify the sex with the highest correlation
highest_cor_sex <- names(which.max(correlation_by_sex))

# Display the sex showing the highest correlation
highest_cor_sex


#1 C3)

#Identify the abalone with the most rings
abalone_most_rings <- which.max(abalone$rings)

#Show the weights for this abalone
abalone[abalone_most_rings, c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")]

#1 C4)
# Get our numerator
amt_viscwt_gt_shellwt <- sum(abalone$viscera_weight > abalone$shell_weight)

# Get our denominator
total_abalones <- nrow(abalone)

# Calculate the %
percent_viscwt_gt_shellwt <- (amt_viscwt_gt_shellwt/total_abalones)*100

# Display the percentage
percent_viscwt_gt_shellwt

#The percentage of abalones that have a viscera weight larger than their shell weight is 6.5%

#1 D)

# Define the weight columns
weight_columns <- c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")

# Calculating the correlation between each weight variable and rings for female abalones

# **Attribution of Sources Note: Here I used assistance from Microsoft Copilot to help me clean up my syntax. I was originally missing "function(col)" and the double brackets around col
cor_F <- sapply(weight_columns, function(col) cor(abalone_F[[col]], abalone_F$rings))

# Calculating the correlation between each weight variable and rings for male abalones
#**Attribution of Sources Note: see previous note
cor_M <- sapply(weight_columns, function(col) cor(abalone_M[[col]], abalone_M$rings))

# Calculating the correlation between each weight variable and rings for infant abalones
#**Attribution of Sources Note: see previous note
cor_I <- sapply(weight_columns, function(col) cor(abalone_I[[col]], abalone_I$rings))

# Combine into a data frame
correlation_table <- rbind(Female = cor_F, Male = cor_M, Infant = cor_I)

# Display the table rounded to 4 decimal places
round(correlation_table, 4)

# 1 E)

# Run T-tests comparing female to male
t_f_m <- t.test(abalone_F$rings, abalone_M$rings)
# Run T-tests comparing female to infant
t_f_i <- t.test(abalone_F$rings, abalone_I$rings)
# Run T-tests comparing male to infant
t_m_i <- t.test(abalone_M$rings, abalone_I$rings)


# Display results
t_f_m
t_f_i
t_m_i


#2 A)

# Impported Data
food_expenditures <- read.table("/Users/joshszczepanski/Desktop/506/506-HW1/food_expenditure.csv", sep = ",", header = TRUE)

#2 B)
# Cleaned up variable names
colnames(food_expenditures) <- c("ID", "Age", "Number of Household Members", "State", "Currency", "Total Food Ependiture", "Grocery Stores Expenditure", "Dining Out Expenditure", "Miscellaneous Food Expenditure", "Amount of times Dined Out", "Is alcohol included in your expenditures?", "Food Assistance Prograns Used") 

#2 C)
# Isolated only those paying in USD
food_expendituresUSD <- food_expenditures[food_expenditures$Currency == "USD", ]

# Show the number of observations before restricting the data
nrow(food_expenditures)

# Show the number of observations after restricting the data
nrow(food_expendituresUSD)

#2 D)
# Remove all responses by people below the age of 18
food_expendituresUSD_AdultsOnly <- food_expendituresUSD[food_expendituresUSD$Age >= 18, ]

#2 E)
# Remove all responses that did not provide a response for State
food_expendituresUSD_AdultsOnly_States <- food_expendituresUSD_AdultsOnly[food_expendituresUSD_AdultsOnly$State != '', ]

#2 F)
# Remove responses where there are food expenditures reported as negative values
food_expendituresUSD_AdultsOnly_States_wonegatives <- food_expendituresUSD_AdultsOnly_States[
  food_expendituresUSD_AdultsOnly_States$`Total Food Ependiture` >= 0 &
  food_expendituresUSD_AdultsOnly_States$`Grocery Stores Expenditure` >= 0 &
  food_expendituresUSD_AdultsOnly_States$`Dining Out Expenditure` >= 0 &
  food_expendituresUSD_AdultsOnly_States$`Miscellaneous Food Expenditure` >= 0, 
]

#2 G
# Remove responses where the number of times dining out exceeds an average of 2x per day
food_expendituresUSD_AdultsOnly_States_wonegatives_nonextremediningout <- food_expendituresUSD_AdultsOnly_States_wonegatives[food_expendituresUSD_AdultsOnly_States_wonegatives$`Amount of times Dined Out`, ]

# Simplify name
food_expenditures_cleaned <- food_expendituresUSD_AdultsOnly_States_wonegatives_nonextremediningout

# Display rows to ensure each step cleaned data
nrow(food_expenditures)
nrow(food_expendituresUSD)
nrow(food_expendituresUSD_AdultsOnly)
nrow(food_expendituresUSD_AdultsOnly_States)
nrow(food_expendituresUSD_AdultsOnly_States_wonegatives)
nrow(food_expendituresUSD_AdultsOnly_States_wonegatives_nonextremediningout)

# Simplify name
food_expenditures_cleaned <- food_expendituresUSD_AdultsOnly_States_wonegatives_nonextremediningout

# 2 H
nrow(food_expenditures_cleaned)
```

