---
title: "506-HW-1"
author: "Josh Szczepanski"
format: html
editor: visual
---


```{r}
#1 A)

#Import the data frame "abalone"
abalone <- read.table("/Users/joshszczepanski/Downloads/abalone/abalone.data", sep = ",", header = FALSE)

#Assign appropriate column names
colnames(abalone) <- c(
  "sex", "length", "diameter", "height",
  "whole_weight", "shucked_weight",
  "viscera_weight", "shell_weight",
  "rings")


#1 B)
#Generate a table that shows the number of observations belonging to each sex
table(abalone$sex)

# The table shows F: 1307, I: 1342, M: 1528


#1 C1)
#Isolate just the weights and rings columns
allweights_and_rings_column <- abalone[ ,c("whole_weight", "shucked_weight",
  "viscera_weight", "shell_weight", "rings")]
                      
# Compute correlations between the first 4 columns (the weights) and the 'rings' column using sapply
correlations_with_rings <- sapply(allweights_and_rings_column[1:4], function(x) cor(x, allweights_and_rings_column$rings))

correlations_with_rings

# Identify which weight has the highest correlation.  

# **Attribution of Sources Note: Here I used assistance from Microsoft Copilot to help figure out that I need to use the "names" function. Initially, I wrote which.max(correlations_with_rings) and that just returned me the column number '4'

max_cor_weight <- names(which.max(correlations_with_rings))

# Identify correlation of highest correlating weight.
max_cor_value <- max(correlations_with_rings)


# Display weight with highest correlation and its value
max_cor_weight
max_cor_value

# The weight with the highest correlation is: shell_weight it has a correlation of 0.6276 

#1 C2)

#Isolate each sex 
abalone_F <- abalone[abalone$sex == "F", ]
abalone_M <- abalone[abalone$sex == "M", ]
abalone_I <- abalone[abalone$sex == "I", ]

# Store the correlations of shell weight and rings for each isolated sex
correlation_F <- cor(abalone_F$shell_weight, abalone_F$rings)
correlation_M <- cor(abalone_M$shell_weight, abalone_M$rings)
correlation_I <- cor(abalone_I$shell_weight, abalone_I$rings)

# Store correlations into one vector

# **Attribution of Sources Note: Here I used assistance from Microsoft Copilot to help me figure out that I needed to set each correlation equal to the original sex names and couldn't just write c(correlation_F, correlation_M, correlation_I)

correlation_by_sex <- c(F = correlation_F, M = correlation_M, I = correlation_I)

# Display the correlations
correlation_by_sex

# Identify the sex with the highest correlation
highest_cor_sex <- names(which.max(correlation_by_sex))

# Display the sex showing the highest correlation
highest_cor_sex

#The sex with the highest Correlation is infant (I)

#1 C3)

#Identify the abalone with the most rings
abalone_most_rings <- which.max(abalone$rings)

#Show the weights for this abalone
abalone[abalone_most_rings, c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")]

#The whole weight for the abalone with the most rings is: 1.8075
#The shucked weight for the abalone with the most rings is: 0.7055
#The viscera weight for the abalone with the most rings is: 0.3215
#The shell weight for the abalone with the most rings is: 0.475

#1 C4)
# Get our numerator
amt_viscwt_gt_shellwt <- sum(abalone$viscera_weight > abalone$shell_weight)

# Get our denominator
total_abalones <- nrow(abalone)

# Calculate the %
percent_viscwt_gt_shellwt <- (amt_viscwt_gt_shellwt/total_abalones)*100

# Display the percentage
percent_viscwt_gt_shellwt

#The percentage of abalones that have a viscera weight larger than their shell weight is 6.5%

#1 D)

# Define the weight columns
weight_columns <- c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")

# Calculating the correlation between each weight variable and rings for female abalones

# **Attribution of Sources Note: Here I used assistance from Microsoft Copilot to help me clean up my syntax. I was originally missing "function(col)" and the double brackets around col
cor_F <- sapply(weight_columns, function(col) cor(abalone_F[[col]], abalone_F$rings))

# Calculating the correlation between each weight variable and rings for male abalones
#**Attribution of Sources Note: see previous note
cor_M <- sapply(weight_columns, function(col) cor(abalone_M[[col]], abalone_M$rings))

# Calculating the correlation between each weight variable and rings for infant abalones
#**Attribution of Sources Note: see previous note
cor_I <- sapply(weight_columns, function(col) cor(abalone_I[[col]], abalone_I$rings))

# Combine into a data frame
correlation_table <- rbind(Female = cor_F, Male = cor_M, Infant = cor_I)

# Display the table rounded to 4 decimal places
round(correlation_table, 4)

# 1 E)

# Run T-tests comparing female to male
t_f_m <- t.test(abalone_F$rings, abalone_M$rings)
# Run T-tests comparing female to infant
t_f_i <- t.test(abalone_F$rings, abalone_I$rings)
# Run T-tests comparing male to infant
t_m_i <- t.test(abalone_M$rings, abalone_I$rings)


# Display results
t_f_m
# t = 3.6657, df = 2742.4, p-value = 0.0002514
t_f_i
# t = 29.477, df = 2508.9, p-value < 2.2e-16
t_m_i
# t = 27.221, df = 2859, p-value < 2.2e-16


#2 A)

# Impported Data
food_expenditures <- read.table("/Users/joshszczepanski/Desktop/506/506-HW1/food_expenditure.csv", sep = ",", header = TRUE)

#2 B)
# Cleaned up variable names
colnames(food_expenditures) <- c("ID", "Age", "Number of Household Members", "State", "Currency", "Total Food Ependiture", "Grocery Stores Expenditure", "Dining Out Expenditure", "Miscellaneous Food Expenditure", "Amount of times Dined Out", "Is alcohol included in your expenditures?", "Food Assistance Prograns Used") 

#2 C)
# Isolated only those paying in USD
food_expendituresUSD <- food_expenditures[food_expenditures$Currency == "USD", ]

# Show the number of observations before restricting the data
nrow(food_expenditures)

# Show the number of observations after restricting the data
nrow(food_expendituresUSD)

#2 D)
# Remove all responses by people below the age of 18
food_expendituresUSD_AdultsOnly <- food_expendituresUSD[food_expendituresUSD$Age >= 18, ]

#2 E)
# Remove all responses that did not provide a response for State
food_expendituresUSD_AdultsOnly_States <- food_expendituresUSD_AdultsOnly[food_expendituresUSD_AdultsOnly$State != '', ]

#2 F)
# Remove responses where there are food expenditures reported as negative values
food_expendituresUSD_AdultsOnly_States_wonegatives <- food_expendituresUSD_AdultsOnly_States[
  food_expendituresUSD_AdultsOnly_States$`Total Food Ependiture` >= 0 &
  food_expendituresUSD_AdultsOnly_States$`Grocery Stores Expenditure` >= 0 &
  food_expendituresUSD_AdultsOnly_States$`Dining Out Expenditure` >= 0 &
  food_expendituresUSD_AdultsOnly_States$`Miscellaneous Food Expenditure` >= 0, 
]

#2 G)
# Remove responses where the number of times dining out exceeds an average of 2x per day
food_expendituresUSD_AdultsOnly_States_wonegatives_nonextremediningout <- food_expendituresUSD_AdultsOnly_States_wonegatives[food_expendituresUSD_AdultsOnly_States_wonegatives$`Amount of times Dined Out`, ]

# Simplify name
food_expenditures_cleaned <- food_expendituresUSD_AdultsOnly_States_wonegatives_nonextremediningout

# Display rows to ensure each step cleaned data
nrow(food_expenditures)
nrow(food_expendituresUSD)
nrow(food_expendituresUSD_AdultsOnly)
nrow(food_expendituresUSD_AdultsOnly_States)
nrow(food_expendituresUSD_AdultsOnly_States_wonegatives)
nrow(food_expendituresUSD_AdultsOnly_States_wonegatives_nonextremediningout)

# Simplify name
food_expenditures_cleaned <- food_expendituresUSD_AdultsOnly_States_wonegatives_nonextremediningout

# 2 H)
nrow(food_expenditures_cleaned)



# 3 A)

#' Compute the next number in the Collatz sequence
#'
#' @param x A positive integer
#'
#' @returns The next integer in the Collatz sequence
#' @export
#'
#' @examples

nextCollatz <- function(x) {
  if (x <= 0 | x %% 1 != 0)
    return("Please input a positive integer")
  else if((x/2) %% 1 == 0)
    returnValue(x/2)
  else
    returnValue((3*x)+1)
  
}

# Demonstrate it works by reproducing the examples.
nextCollatz(5)
nextCollatz(16)


# 3 B)

#' Generate the full Collatz sequence from a starting value
#'
#' @param x A positive integer
#'
#' @returns A numeric vector containing the Collatz sequence
#' @export
#'
#' @examples
collatzSequence <- function(x) {
  if (x <= 0 || x %% 1 != 0) {
    return("Please input a positive integer")
  }
  
  sequence <- c(x)
  
  while (x != 1) {
    x <- nextCollatz(x)
    sequence <- c(sequence, x)
  }
  
  return(sequence)
}


collatzSequence(5)
collatzSequence(19)

# 3 C)

# Set starting points extreme enough that they will certainly be eclipsed
shortest_length <- 10000
longest_length <- 0
shortest_number <- 1
longest_number <- 1

# Identify the starting values between 100 and 500 that produce the shortest and longest Collatz sequences
for (i in 100:500) {
  seq <- collatzSequence(i)
  len <- length(seq)
  
  if (len < shortest_length) {
    shortest_length <- len 
    shortest_number <- i
  }
  
  if(len > longest_length){
    longest_length <- len 
    longest_number <- i
  }
}


# Demonstrate it works by reproducing the examples.
shortest_length
longest_length
shortest_number
longest_number

# Display results
cat("The value with the shortest sequence is:", shortest_number, "with length:", shortest_length, "\n")
cat("The value with the longest sequence is:", longest_number, "with length:", longest_length, "\n")

# The value with the shortest sequence is: 128 with length: 8 
# The value with the longest sequence is: 327 with length: 144 
```

